#!/usr/bin/env node

var program = require('commander')
  , fs = require('fs')
  , path = require('path')
  , util = require('util')
  , extend = require('extend')
  , Handlebars = require('handlebars')
  , objmerge = require('object-merge');

global.Handlebars = Handlebars;

// borrowed from spec/env/node.js
global.handlebarsEnv = Handlebars;
function safeEval(templateSpec) {
  try {
    return eval('(' + templateSpec + ')');
  } catch (err) {
    console.error("SPEC:". templateSpec);
    throw err;
  }
}
global.CompilerContext = {
  compile: function(template, options) {
    //return handlebarsEnv.compile(template, options);
    var templateSpec = global.handlebarsEnv.precompile(template, options);
    return global.handlebarsEnv.template(safeEval(templateSpec));
  },
  compileWithPartial: function(template, options) {
    return global.handlebarsEnv.compile(template, options);
  }
};
require('../handlebars.js/spec/env/common.js');
//require('../handlebars.js/spec/env/node.js');


// Sigh - not sure why this isn't working right (for builtins #each)
Handlebars.registerHelper('detectDataInsideEach', function(options) {
    return options.data && options.data.exclaim;
});


// Utils

function unstringifyHelpers(helpers) {
    if( !helpers | helpers === null ) {
        return;
    }
    var ret = {};
    for( var x in helpers ) {
        ret[x] = safeEval(helpers[x].javascript);
    }
    return ret;
}

function unstringifyLambdas(data) {
    if( !data || data === null ) {
        return data;
    }
    for( var x in data ) {
        if( data[x] instanceof Array ) {
            unstringifyLambdas(data[x]);
        } else if( typeof data[x] === 'object' && data[x] !== null ) {
            if( '!code' in data[x] ) {
                data[x] = safeEval(data[x].javascript);
            } else {
                unstringifyLambdas(data[x]);
            }
        }
    }
    return data;
}

function runTest(test) {
    var result = null;
    switch( test.suite ) {
        case 'tokenizer':
            // not yet implemented
            break;
        case 'basic':
        case 'blocks':
        case 'builtins': // a little broken
        //case 'data': // very broken
        case 'helpers': // a little broken
        //case 'partials': // a little broken
        //case 'regressions': // mostly working
        //case 'string-params': // very broken
        //case 'subexpressions': // very broken
        //case 'track-ids': // very broken
        case 'whitespace-control':
            result = runTestGeneric(prepareTestGeneric(test, suite));
            break;
        default:
            break;
    }
    return result;
}

function prepareTestGeneric(test, suite) {
    var spec = {};
    // Output prefix
    spec.prefix = '(' + suite + ' - ' + test.it + ' - ' + test.description + '): ';
    // Template
    spec.template = test.template;
    // Expected
    spec.expected = test.expected;
    // Exception
    spec.exception = (test.exception ? true : false);
    // Data
    spec.data = (test.data !== undefined ? JSON.parse(JSON.stringify(test.data)) : undefined);
    unstringifyLambdas(spec.data);
    // Helpers
    spec.helpers = unstringifyHelpers(test.helpers);
    // Partials
    spec.partials = test.partials;
    // Options
    spec.options = test.options || undefined;
    spec.compileOptions = test.compileOptions || undefined;
    return spec;
}

function checkResult(test, e) {
    if( (test.exception === true) === (e !== undefined) ) {
        console.log(test.prefix + 'OK');
        return true;
    } else {
        console.log(test.prefix + (e || 'Error: should have thrown, did not'));
        e && console.log(e.stack);
        console.log('Test Data: ', test);
        return false;
    }
}

function runTestGeneric(test) {
    try {
        // Execute
        if( test.options || test.compileOptions ) {
            var template = global.CompilerContext.compile(test.template, test.compileOptions);
            var opts = test.options === undefined ? {} : JSON.parse(JSON.stringify(test.options));
            if( test.helpers ) {
                opts.helpers = test.helpers;
            }
            var actual = template(test.data, opts);
            global.equals(actual, test.expected);
        } else {
            // Prepare arguments
            var hashOrArray;
            if( test.data !== undefined || test.helpers || test.partials ) {
                hashOrArray = [test.data, test.helpers, test.partials]
            }
            shouldCompileTo(test.template, hashOrArray, test.expected, 'generated by runner');
        }
        return checkResult(test);
    } catch(e) {
        return checkResult(test, e);
    }
}


// Main
var dir = path.resolve('./spec/');
var specs = fs.readdirSync(dir);
var successes = [];
var failures = [];
var skipped = [];

for( var x in specs ) { 
    var suite = specs[x].replace(/\.json$/, '');
    var data = require(dir + '/' + specs[x]);
    for( var y in data ) { 
        data[y].suite = suite;
        var result = runTest(data[y]);
        if( result === null ) {
            skipped.push(data[y]);
        } else if( result === true ) {
            successes.push(data[y]);
        } else {
            failures.push(data[y]);
        }
    }
}


// Results
console.log('Summary');
console.log('Success: ' + successes.length);
console.log('Failed: ' + failures.length);
console.log('Skipped: ' + skipped.length);

// Exit
process.exit(failures.length ? 2 : 0);
